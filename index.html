let linkCache = null;
let linkCacheTimestamp = 0;
const CACHE_EXPIRATION_TIME = 5 * 60 * 1000;

let weightCache = {
  timestamp: 0,
  values: [],
};
const WEIGHT_CACHE_TTL = 5 * 60 * 1000;

export default {
  async fetch(request, env, ctx) {
    const { method } = request;
    const { pathname } = new URL(request.url);

    const corsHeaders = {
      "Access-Control-Allow-Origin": "*",
      "Access-Control-Allow-Methods": "GET, POST, OPTIONS",
      "Access-Control-Allow-Headers": "Content-Type",
    };

    if (method === "OPTIONS") {
      return new Response(null, { status: 204, headers: corsHeaders });
    }

    const jsonResponse = (data, status = 200) =>
      new Response(JSON.stringify(data), {
        status,
        headers: { "Content-Type": "application/json", ...corsHeaders },
      });

    async function getLinkPool() {
      const now = Date.now();
      if (!linkCache || now - linkCacheTimestamp > CACHE_EXPIRATION_TIME) {
        const raw = await env.LINK_POOL.get("linkPool");
        linkCache = raw ? JSON.parse(raw).links : [];
        linkCacheTimestamp = now;
      }
      return linkCache;
    }

    async function updateLinkPool(links, env) {
      await env.LINK_POOL.put("linkPool", JSON.stringify({ links }));
      linkCache = links;
      linkCacheTimestamp = Date.now();
      weightCache.timestamp = 0;
    }

    async function getClickCounts(links, env) {
      const keys = links.map((_, i) => `clickCount-${i}`);
      const values = await env.LINK_POOL.getMany(keys);
      return values.map((v) => parseInt(v || "0"));
    }

    async function updateClick(env, indices) {
      const keys = indices.map((i) => `clickCount-${i}`);
      const values = await env.LINK_POOL.getMany(keys);
      const updates = values.map((v) => (parseInt(v || "0") || 0) + 1);

      await env.LINK_POOL.putMany(
        keys.map((key, i) => ({ key, value: updates[i].toString() }))
      );
    }

    async function selectWeightedIndex(links, env) {
      const now = Date.now();
      const needsRefresh =
        weightCache.timestamp + WEIGHT_CACHE_TTL < now ||
        weightCache.values.length !== links.length;

      if (needsRefresh) {
        const weights = await Promise.all(
          links.map((_, i) =>
            env.LINK_POOL.get(`clickCount-${i}`).then((v) => 1 / ((parseInt(v || "0") || 0) + 1))
          )
        );
        weightCache = {
          timestamp: now,
          values: weights,
        };
      }

      const weights = weightCache.values;
      const total = weights.reduce((sum, w) => sum + w, 0);
      const rand = Math.random() * total;
      let cum = 0;
      for (let i = 0; i < weights.length; i++) {
        cum += weights[i];
        if (rand <= cum) return i;
      }
      return Math.floor(Math.random() * links.length);
    }

    async function getTargetIndex(request, links, env) {
      const cookie = request.headers.get("Cookie") || "";
      const match = cookie.match(/target=(\d+)/);
      let index = match ? parseInt(match[1]) : null;

      if (index === null || index >= links.length) {
        index = await selectWeightedIndex(links, env);
      }
      return index;
    }

    // ğŸ‘‰ GET: è·å–é“¾æ¥åŠç»Ÿè®¡
    if (pathname === "/api/links" && method === "GET") {
      try {
        const links = await getLinkPool();
        const counts = await getClickCounts(links, env);
        const enriched = links.map((l, i) => ({ ...l, clicks: counts[i] || 0 }));
        return jsonResponse({ links: enriched });
      } catch (error) {
        console.error("[API Error] è·å–é“¾æ¥åˆ—è¡¨å¤±è´¥:", error);
        return jsonResponse({ error: "å†…éƒ¨é”™è¯¯: è·å–ç‚¹å‡»ç»Ÿè®¡å¤±è´¥" }, 500);
      }
    }

    // ğŸ‘‰ POST: ä¿å­˜é“¾æ¥æ± 
    if (pathname === "/api/links" && method === "POST") {
      try {
        const body = await request.json();
        if (!Array.isArray(body.links)) throw new Error("å¿…é¡»ä¼ å…¥ links æ•°ç»„");
        await updateLinkPool(body.links, env);
        return jsonResponse({ message: "ä¿å­˜æˆåŠŸ" });
      } catch (err) {
        console.error("[API Error] æ›´æ–°é“¾æ¥æ± å¤±è´¥:", err);
        return jsonResponse({ error: err.message }, 400);
      }
    }

    // ğŸ‘‰ GET: è·å–ç›®æ ‡é“¾æ¥ä¿¡æ¯ï¼ˆä¸è·³è½¬ï¼‰
    if (pathname === "/api/target" && method === "GET") {
      const links = await getLinkPool();
      const index = await getTargetIndex(request, links, env);
      const link = links[index];
      if (!link?.url || !/^https?:\/\//.test(link.url)) {
        return new Response("æ— æ•ˆé“¾æ¥", { status: 400, headers: corsHeaders });
      }
      return jsonResponse({ target: { name: link.name, url: link.url }, index });
    }

    // ğŸ‘‰ GET: æ ¹è·¯å¾„è·³è½¬å¤„ç†
    if (pathname === "/" && method === "GET") {
      const links = await getLinkPool();
      const index = await getTargetIndex(request, links, env);
      const target = links[index];
      if (!target?.url) {
        return new Response("é…ç½®é”™è¯¯", { status: 400 });
      }

      ctx.waitUntil(updateClick(env, [index]));

      return new Response(null, {
        status: 302,
        headers: {
          Location: target.url,
          "Set-Cookie": `target=${index}; Path=/; Max-Age=2592000`,
        },
      });
    }

    // é»˜è®¤ 404 å“åº”
    return new Response("Not Found", { status: 404, headers: corsHeaders });
  },
};
